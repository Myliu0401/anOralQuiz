/**
 * 
 *         HTTP 1.0
 *            无法复用链接
 *            http1.0为每个请求单独新开一个TCP链接
 *  
 *            由于每个请求都是独立的链接，因此会带来几个问题：
 *                1. 链接的建立和销毁都会占用服务器和客户端的资源，造成内存资源的浪费
 *                2. 链接的建立和销毁都会消耗时间，造成响应时间的浪费
 *                3. 无法充分利用宽带，造成宽带资源的浪费
 *                   就是 tcp传输一开始速度慢，然后会越来越快，可能还没达到顶峰，传输完毕断开链接了
 * 
 *                队头阻塞
 *                    必须要等待上一个TCP链接断掉后，才会开启下一个TCP链接，所以100个请求进行的话，后面的会造成阻塞。
 *                    这就是【慢启动】
 * 
 * 
 *          HTTP 1.1
 *             长连接
 *               为了解决http1.0的问题，http1.1默认开启长连接，即让同一个TCP链接服务于多个请求-响应
 * 
 *             在这种情况下，多次请求响应可以共享同一个TCP链接，这不仅减少了TCP的握手和挥手时间，同时可以充分利用TCP【慢启动】的特点，有效的利用带宽。
 *             
 *             实际上，http1.0后期，虽然没有官方标准，但开发者们慢慢形成了一个共识：
 *              只要在请求头中包含 Connection: keep-alive 就表示客户端希望开启长连接，希望服务器响应后不要关闭TCP链接。
 * 
 *             当需要的时候，任何一方都可以关闭TCP链接
 *                1. 客户端在某一次请求中设置了 Connection:close, 服务器收到该请求后，响应结束立即关闭TCP
 *  
 *                2. 在没有请求时，客户端会不断对服务器进行心跳检测（一般每个1秒），一旦心跳检测停止，服务器立即关闭TCP
 * 
 *                3. 当客户端长时间没有新的请求到达服务器，服务器会主动关闭TCP，运维人员可以设置该时间。
 * 
 *               由于一个TCP链接可以承载多次请求响应，并在一段时间内不会断开，因此这种链接称之为长连接
 * 
 *             管道化和队头阻塞
 *               http1.1允许在响应到达之前发送下一个请求，这样可以大幅缩减带宽限制时间
 *               但这样做会存在对头阻塞的问题
 *               由于多个请求使用的是同一个TCP链接，服务器必须按照请求到达的顺序进行响应。不然客户端就不知道哪个对应哪个了。
 * 
 *               优化手段
 *                 减少文件数量，从而减少对头阻塞的几率
 *                 开辟多个TCP链接，实现真正的、有缺陷的并行传输
 *                  浏览器对同个域名最多开时开启6个TCP链接，如果想要突破这个限制，就需要把资源放到不同的域中
 * 
 * 
 * 
 *          HTTP 2.0
 *              二进制分帧
 *               http2.0可以允许以更小单元传输数据，每个传输单元称之为 帧 ，而每一个请求或响应的完整数据称之为 流，每个
 *               流有自己的编号，每个帧会记录所属的流。
 * 
 *               比如，服务器链接到了客户端的两个请求，一个请求JS、一个请求CSS
 * 
 *               http2.0会进行分帧传输，每一帧都有一个头部，头部信息记录流和帧的信息
 *               
 *               如：头部(类型：请求头，所属的流编号：1，所属的帧：1)、主体(请求头信息)
 * 
 *               这样就真正的解决了共享TCP链接时的队头阻塞问题，实现了真正的 多路复用。
 * 
 *               由于传输时是以帧为单元传输的，无论是响应还是请求，都可以实现并发处理，就是不同的传输可以交替进行。
 * 
 *               由于进行了分帧，还可以设置传输优先级
 * 
 *               头部压缩
 *                 http2.0之前，所有的消息头都是以字符串的形式完整传输的，但是
 *                 大部分头部信息都有很多重复的，所以http2.0进行处理头部信息。
 * 
 *                 会使用静态表来映射头部信息
 *                 如：客户端和服务端都有一张静态表
 *                 
 *                     客户端传过去的头部变成
 *                        1
 *                        2
 *                        3
 *                     服务端收到后就从静态表里面查找映射的
 *  
 *                     服务端响应时也可以这样，然后客户端从静态表中查找映射的。
 * 
 *                服务器推
 *                   http2.0允许在客户端没有主动请求的情况下，服务器预先把资源推送给客户端
 *                   但客户端后续需要请求该资源时，则自动从之前推送的资源中寻找。
 *   
 *                   就是tcp链接建立后，服务器主动推过来。
 */