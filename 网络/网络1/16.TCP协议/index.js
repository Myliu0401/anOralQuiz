/* 
       TCP协议在传输层

           TCP收发数据流程
             建立链接（三次握手）
             收发数据
             销毁链接（四次挥手）
     

           TCP收发数据
               分段发送
                 如果数据量过大，则不会一次性发送过去，会分为一小段一小段的发送，每一小段都会带个头部。 
 
               可靠传输
                 在TCP协议中，任何时候、任何一方都可以主动发送数据给另一方。
                  （http协议，只能由客户端发起，http协议是建立在tcp协议基础上的）
                 为了解决数据报丢失、数据报错乱等问题，TCP协议要求：接收方收到数据报后，必须对数据报进行确认。
                 发送每一小段都会带个头部，头部中就包含信息：
                     seq: 表示这小段是整个数据的第几部分
                     ACK: 表示这次数据报是一个确认数据报
                     ack: 表示期望下一次接收的数据报序号
                  接收方收到消息后，将头部中的 ACK、ack 发回给发送方 表示已经确认

                  发送方如果长时间没有收到确认数据报，则会判定丢失或者是错误，然后重发该数据报

                  http协议一次完整请求后就断开，为了释放内存，然后服务器会越级越多。

                建立链接（三次握手）
                   链接的本质就是双方各自开辟一块内存空间，空间中主要是数据缓冲区和一些变量
                   服务器会监听一个端口

                  1. 客户端向服务端发送 SYN包  （表示想要建立链接，此时客户端进行 SYN_SENT状态）
                  2. 服务端收到SYN包后 发回 SYN包+ACK包 给客户端 （服务端表示同意，你那边呢。随后服务端进入 SYN_SENT状态）
                  3. 客户端收到SYN包+ACK包后 将 ACK包发回给服务端 （发回后，客户端进入链接状态。随后服务端收到ACK包后也进入链接状态。通道建立）

                  3次对话完成后，通道建立



                销毁链接通道（四次挥手）
                  销毁链接，任何一方都可以发出销毁链接请求
                  
                  客户端向服务端发送 FIN包 （表示客户端请求关闭链接。随后客户端进入FIN1状态，此时链接通道中客户端不能再向服务端发送数据，但能读取数据）
                  服务端收到 FIN包后，向客户端发送 ACK包 （服务端进入close状态，此后服务端不能再读取数据，但能发送数据）
                  客户端收到 ACK包后（进入FIN2状态，等到服务端发回FIN包）
                     这个阶段服务端仍然可以向客户端发送数据
                  服务端再向客户端发回 FIN包 （服务端进入LAST状态, 此时服务器不能再发送数据。等待客户端发回ACK包）
                  客户端收到 FIN包 后 向服务端发送发回 ACK包（客户端进入TIME状态）
                  服务端收到 ACK包后 关闭链接（释放内存）
                  客户端TINM状态等一会后才会关闭链接（释放内存），以确保 ACK包的发送
                     怕服务端没有收到 ACK包，如果服务端没有收到ACK包，则会继续向客户端发送FIN包，直到客户端发送ACK包。





            http和tcp的关系：
               http是建立在tcp基础上的，所以http也是使用了tcp的链接通过完成传输，http只是规定了消息的格式，和每次响应后就断开。
               使用http协议的服务器不会主动发消息给客户端。
               每个http请求和响应，都要在tcp链接通道进行，请求和响应时独立的无法保持状态。


                  

*/