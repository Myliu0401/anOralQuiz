/**
 *  1. 解析HTML    
 *    网络中传输的内容是0和1这些字节数据，浏览器接收到这些字节数据后
 *    会将这些字节数据转为字符串，也就是我们所写的代码。
 * 
 *    转换成字符串后会通过词法分析转换为标记，会给每个标签打标记便于
 *    理解这些最小单位的代码是什么意思.
 *    因为浏览器将字节数字转换成字符串后是全部挤在一行的。
 *    打标记相当于为这些标签、属性生成语法化
 *    <div class="box">Hello</div> 打标记 
 *     [
         { type: 'startTag', tagName: 'div', attrs: { class: 'box' } },
         { type: 'text', data: 'Hello' },
         { type: 'endTag', tagName: 'div' }
       ]

       标记化完成后就能根据标记化构建出DOM树，在标记化时浏览器会开启一个预解析线程，率先
       扫描一遍HTML，并下载外部资源 css、js、图片等。

       遇到link的css文件没有下载好的话不会等待，而是继续解析DOM。
       遇到js文件的话，渲染线程则会停止解析，等待js文件下载完，并
       由JS线程接管执行JS文件，执行完毕后才会交给渲染线程继续解析DOM
       这就是JS会阻塞渲染的原因。
       解析HTML构建DOM树过程中遇到css也会构建CSS树。
       解析完毕后构建出DOM树和CSS树。


     2. 计算样式
       会递归遍历DOM树，为每个dom节点计算出最终的样式，如 默认样式、继承样式、相对单位计算出绝对单位，
       颜色值计算成rgb，是对每个节点的说有属性进行计算。
       将DOM树和计算后的CSS树合成一个渲染树。
       display:none的节点样式会被跳过，不会为其进行计算。
    
     3. 布局计算
       会递归遍历渲染树，计算每个节点在页面上的 x、y 坐标已经盒子大小等具体信息
       计算布局的过程中会删除或添加一些节点，比如 display:none的节点会将其删除，
       有伪元素的节点则会根据伪元素生成一个子节点等，最终将渲染树变成一颗布局树。

    
     4. 分成
        会对布局树进行分层，滚动条、z-index、透明度等这些样式也会影响分层，分层
        的好处是将来某个节点的样式改变后，只会对该节点的层级进行处理，不会影响到其他层级。

     
     5. 生成绘制指令集
        会为每个层单独生成绘制指令集，用于描述该成如何绘制
        如：从x、y点绘制到x、y点，然后放下画笔等。
        为每个层生成绘制指令集后，渲染线程退出工作，后续工作交给合成线程。


     6. 分块
        合成线程会开启多个线程对每个层级进行分块，分成一小块一小块。

    
     7. 光栅化
        合成线程会将每个层级的块交给GPU进行光栅化，也就是确定每个块的像素色rgb信息，GPU同样会开启
        多个线程来完成光栅化，并且会优先处理视口区块的光栅化。

    
     8. 绘制
        GPU光栅化过后，会将每个块交给合成线程，合成线程根据块来生成quad，也就是计算出每个块在屏幕闪的位置
        transform的旋转、缩放、移动等就是在这个位置处理好变成quad的。
        合成线程把这些quad交给GPU，GPU将其绘制到页面上

        

     回流发生在布局计算开始
     重绘发生在生成绘制指令集开始
 */