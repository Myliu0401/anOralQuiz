/* 
        垃圾回收发生在程序空闲时段

        如何识别垃圾
          JS规范中并没有明确指出js引擎必须使用哪种算法来识别垃圾，最常用的就两种算法 引用计数、垃圾回收

        
        垃圾的产生
           当创建一个数据时，无论是基本类型还是引用类型，都需要占用内存空间，当该数据没办法访问到，则该数据就会成为垃圾。

           引用类型数据都是存放到 堆内存 中，而栈内存中则保存的是基本类型的数据或引用类型数据的引用。
 
        垃圾回收
           垃圾回收机制如果发现数据的不可访问性，也就是如果发现该数据时垃圾，从而进行清理。
           最常用的两种垃圾回收机制   标记清除、引用计数

           标记清除
             垃圾回收时会先给堆内存中的所有数据进行标记 如标记为 0 
             然后递归遍历全局中所有变量，把能访问得到的数据添加标记 1， 该操作过后，堆内存中的引用数据能被访问得到的数据的标记已经变成 1
             再然后会遍历堆内存中所有数据，将标记为 0 的数据进行清理，以释放内存空间。
             最后，把所有内存中数据重新修改为0，等待下一轮的垃圾回收。

            优点： 
               标记清除实现比较点单，只有打不打标记，这两种情况。
              
            缺点：
               标记清除，清除数据释放内存后，内存中会出现空缺，不连续性，形成内存碎片。如  这个位置有东西下个位置没东西。
               如果有新的数据，则不知道存放到内存中的那个位置好。
               解决方案： 
                  First-fit:  遍历内存空间，找到大于等于 数据大小 的块立即返回。
                  Best-fit:   遍历内存空间，并返回大于等于 数据大小 的最小分块
                  Wirst-fit:  遍历内存空间，找到最大的分块，然后惊醒切换，一个部分装载 数据。
                  这三种方案都有缺点，就是每次有新数据时，都要遍历内存找到合适的空间进行存放数据，导致分配速度慢，效率不高。
                  
              产生了另一种算法  标记整理
                该算法可以有效的解决 内存碎片和分配速度的缺点。
                该算法就是在标记清除完毕后对内存进行重新排列，将能访问到的数据向一端靠拢，从而所有位置有东西，最后清理掉边界的内存位置。

              标记清除算法需要每隔一段时间进行一次，当执行标记清除时，js主线程必须来执行垃圾回收，所以会导致逻辑程序卡顿。
          
           引用计数
             跟踪记录每个数据被引用的次数
                当声明了一个变量并且将一个引用类型数据赋值给该变量的时候这个数据的引用次数就为1
                如果同一个数据又被赋值给另一个变量，那么引用次数加 1
                如果该变量的值被其他数据覆盖，则引用次数减 1
             当这个数据的引用次数为0时，说明该数据不能被访问到，这个数据就会被清理以释放内存。

             let a = new Object() 	// 此对象的引用计数为 1（a引用）
             let b = a 		// 此对象的引用计数是 2（a,b引用）
             a = null  		// 此对象的引用计数为 1（b引用）
             b = null 	 	// 此对象的引用计数为 0（无引用）

             缺点：这种有一个致命的缺点，就如果在函数中或者循环引用，那么数据将无法被清理，从而导致内存无法释放。
                function test(){
                  let A = new Object()
                  let B = new Object()
                  
                  A.b = B
                  B.a = A
                }

              优点： 引用计数，是实时的，当发现数据的引用为0时，就会进行清理。

          
          V8对垃圾回收的优化
             当进行垃圾回收时，都要遍历堆内存中所有数据，这样的话，对一些 大、老、存活时间长的数据来说同 新、小、存活时间短的数据
             一个频率的检查很不好。
             所以V8对该点进行优化，形成分代式垃圾回收

             分代式垃圾回收：将堆内存划分为新生代区和老生代区，两个区的垃圾回收策略不同。

               新生代区存放 存活时间较短的数据 新生代区容量小，老生代区存放存活时间较长的数据，老生代区容量大。
                
               新生代区
                   新生代区将内存划分为二，分为使用区和空闲区。
                   新创建的引用数据会被存放到使用区中，当使用区快被写满时，就执行一次垃圾回收操作。
                   当进行垃圾回收时，新生代垃圾回收会将使用区中的所有数据进行标记 0，然后进行遍历递归所有变量，能访问到的数据标记为 1
                   然后将标记为1的数据 复制到空闲区并进行排序，随后将使用区的所有数据清除，最后将使用区和空闲区翻转。使用区变成空闲区，空闲区变成使用区。
                  
                 当一个数据经过多次复制之后依然存活（能访问到），该数据将会被提到老生代区或者该数据占用使用区内存的25%，则也会被提到老生代区。

               
               老生代区
                  老生代区不用跟新生代区一样复制来复制去，直接将所有数据标记为 0，然后递归遍历全局变量把能访问到的数据标记为 1
                  然后把所有标记为0的数据清理，最后对内存重新排序，将能访问到的数据向一端靠拢，从而所有位置有东西，最后清理掉边界的内存位置。
                  也就是使用标记整理。

            这个优化使其不用遍历所有数据，和将堆内存进行切分，不用每次都遍历整个堆内存。从而提高效率节省垃圾回收时间。
    
        
               


          





*/